package logmaker

import "time"

// OutputKind defines the valid output channels to where the log messages should be printed.
type OutputKind string

const (
	// OutputKindFile means the log messages should be written to a file.
	OutputKindFile OutputKind = "File"

	// OutputKindStdErr means the log messages should be written to STDERR
	OutputKindStdErr OutputKind = "StdErr"

	// OutputKindStdOut means the log messages should be written to STDOUT
	OutputKindStdOut OutputKind = "StdOut"
)

// ContentType defines the valid content types that a log message could have.
type ContentType string

const (
	// ContentTypeExplicit means the log messages are explicitly defined.
	ContentTypeExplicit ContentType = "Explicit"

	// ContentTypeRandom means the log messages have a contain a predefined number of random characters
	ContentTypeRandom ContentType = "Random"
)

// Phase defines the valid phases that a LogTask may have.
type Phase string

const (
	// PhaseIdle means a task is not running.
	PhaseIdle Phase = "Idle"

	// PhaseRunning means a task is running.
	PhaseRunning Phase = "Running"

	// PhaseStopped means a task has finished without any error.
	PhaseStopped Phase = "Stopped"

	// PhaseFailed means a task has abnormally stopped functioning.
	PhaseFailed Phase = "Failed"
)

// LogTask describes a running LogTask.
type LogTask struct {
	Metadata `json:"metadata"`
	Spec     *LogTaskSpec   `json:"spec"`
	Status   *LogTaskStatus `json:"status"`
}

// Metadata stores the metadata of a LogTask.
type Metadata struct {
	Name              string    `json:"name"`
	CreationTimestamp time.Time `json:"creationTimestamp,omitempty"`
}

// LogTaskSpec defines how should a log sending task work. It contains information including what to send, where
// should the log messages go, and how often to send them.
type LogTaskSpec struct {
	// OutputKind is the output channel to be used.
	OutputKind OutputKind `json:"outputKind"`

	// Path to the log file; only effective if `OutputKind` is `File`.
	Filepath string `json:"filepath,omitempty"`

	// TimestampFormat is the format of the timestamp in front of every log message. If TimestampFormat is not a
	// valid timestamp format, it will be used in place of the timestamps. Set it to an empty string to disable
	// timestamp.
	TimestampFormat string `json:"timestampFormat,omitempty"`

	// ContentType determines whether Message or MinSize should be used to produce the logs.
	ContentType ContentType `json:"contentType"`

	// Message is the exact message that each log should print
	// Message must hold non-zero value if and only if ContentType is ContentTypeExplicit
	Message string `json:"message,omitempty"`

	// MinSize defines size in bytes of each log message. The size includes the size of the timestamp, if there
	// is one. The actual message might be larger than MinSize due to timestamp and name prefix.
	// MinSize must hold non-zero value if and only if ContentType is ContentTypeRandom
	MinSize int `json:"minSize,omitempty"`

	// Interval defines logging interval, or the amount of time, in seconds, to wait in-between log messages.
	Interval float64 `json:"interval"`
}

// LogTaskStatus describes the status of a running log task.
type LogTaskStatus struct {
	// Phase is the current phase that the task is in.
	Phase Phase `json:"phase"`

	// PhaseTimestamp is the time at which the current phase started.
	PhaseTimestamp time.Time `json:"phaseTimestamp"`

	// Reason describes why the task is in its current phase.
	Reason string `json:"reason,omitempty"`

	// The number of logs messages that a running log task has produced.
	SentCount int64 `json:"sentCount"`

	// The size in bytes of logs messages that a running log task has produced.
	SentBytes int64 `json:"sentBytes"`
}

// LogTaskList describes a list of tasks.
type LogTaskList struct {
	Total    int       `json:"total"`
	LogTasks []LogTask `json:"tasks,omitempty"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LogTask) DeepCopyInto(out *LogTask) {
	*out = *in
	out.Metadata = in.Metadata
	if in.Spec != nil {
		in, out := &in.Spec, &out.Spec
		*out = new(LogTaskSpec)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(LogTaskStatus)
		**out = **in
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LogTask.
func (in *LogTask) DeepCopy() *LogTask {
	if in == nil {
		return nil
	}
	out := new(LogTask)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LogTaskSpec) DeepCopyInto(out *LogTaskSpec) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LogTaskSpec.
func (in *LogTaskSpec) DeepCopy() *LogTaskSpec {
	if in == nil {
		return nil
	}
	out := new(LogTaskSpec)
	in.DeepCopyInto(out)
	return out
}
